<!-- https://developers.google.com/mediapipe/solutions/vision/pose_landmarker/ -->
<!-- https://github.com/ayushgdev/MediaPipeCodeSamples/blob/main/Vanilla%20JS/face%20detection%20with%20secondary%20cams.html -->

<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils_3d/control_utils_3d.js"
    crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>

<body>
  <div class="container">
    <select id="cameraSelect"></select>
    <video class="input_video"></video>
    <canvas class="output_canvas" width="1280px" height="720px"></canvas>
    <div class="landmark-grid-container"></div>
  </div>
</body>

<script type="module">
  let poses;
  const POSITION_INTERVAL = 20;
  var ifMax = detectMax() || false;

  detectMax();

  function detectMax() {
    try {
      /*
        For references to all functions attached to window.max object read the
        "Communicating with Max from within jweb" document from Max documentation.
      */
      window.max.outlet('setup_ok');
      // posesToMax();
      window.max.outlet('setting ifmax to true?' + ifMax);

      return true;
    }
    catch (e) {
      console.log('Max, where are you?');
    }
    return false;
  }

  var videoElement = document.getElementsByClassName("input_video")[0];
  var testVideoElement = document.getElementsByClassName("test_video")[0];
  videoElement.play();
  const selectElement = document.getElementById('cameraSelect');

  const canvasElement = document.getElementsByClassName("output_canvas")[0];
  const canvasCtx = canvasElement.getContext("2d");
  const landmarkContainer = document.getElementsByClassName(
    "landmark-grid-container"
  )[0];
  const grid = new LandmarkGrid(landmarkContainer);

  // Get available media devices
  navigator.mediaDevices.enumerateDevices()

    .then((devices) => {
      // Filter video devices
      const videoDevices = devices.filter(device => device.kind === 'videoinput');
      selectElement.innerHTML = '';

      // Populate the camera select dropdown
      videoDevices.forEach((device, index) => {
        const option = document.createElement('option');
        option.value = device.deviceId;
        option.label = device.label;
        option.text = device.label || `Camera: ${device.kind} - ${device.label} - ${index + 1}`;
        selectElement.appendChild(option);
        if (ifMax) {
          window.max.outlet('adding camera to options: ', device.deviceId, device.label, index);
        }
        selectElement.value = device.deviceId;
      });
    })
    .catch((error) => {
      console.error('Error accessing media devices:', error);
    }).finally(() => {
      // Start video stream with default camera
      startVideoStream(selectElement.value);
    });

  // Handle camera selection change
  selectElement.addEventListener('change', (event) => {
    const deviceId = event.target.value;
    console.log(`Change camera to: ${deviceId.Camera}`);
    startVideoStream(deviceId);
  });

  // Start video stream with selected camera
  function startVideoStream(deviceId) {

    // Pause existing stream, if any
    videoElement.pause();
    // Close existing stream, if any
    if (videoElement.srcObject) {

      videoElement.srcObject.getTracks().forEach(track => {
        window.max.outlet(`closing existing stream ${track.label}`);
        track.stop();
      });
    }
    videoElement.srcObject = null;

    // Request video stream from selected camera
    navigator.mediaDevices.getUserMedia({
      video: { deviceId: { exact: deviceId } }
    })
      .then((stream) => {
        videoElement.srcObject = stream;
        videoElement.play();
        videoElement.onloadedmetadata = () => {
          // once the video stream is loaded, request a callback
          const frameProcessing = (now, metadata) => {
            processFrame();
            videoElement.requestVideoFrameCallback(frameProcessing);
          }
          videoElement.requestVideoFrameCallback(frameProcessing);
        };
      })
      .catch((error) => {
        console.error('Error accessing camera:', error);
      });

    // Start pose detection
    const pose = new Pose({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
      },
    });

    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: true,
      smoothSegmentation: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });
    pose.onResults(onResults);

    async function processFrame() {
      // Send the videoElement to the MediaPipe
      await pose.send({ image: videoElement });
    }

    posesToMax();
  }

  ///
  function onResults(results) {
    if (!results.poseLandmarks) {
      grid.updateLandmarks([]);
      return;
    }

    poses = results.poseLandmarks;

    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    canvasCtx.drawImage(
      results.segmentationMask,
      0,
      0,
      canvasElement.width,
      canvasElement.height
    );

    // Only overwrite existing pixels.
    canvasCtx.globalCompositeOperation = "source-in";
    canvasCtx.fillStyle = "#00FF00";
    canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

    // Only overwrite missing pixels.
    canvasCtx.globalCompositeOperation = "destination-atop";
    canvasCtx.drawImage(
      results.image,
      0,
      0,
      canvasElement.width,
      canvasElement.height
    );

    canvasCtx.globalCompositeOperation = "source-over";
    drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {
      color: "#00FF00",
      lineWidth: 4,
    });
    drawLandmarks(canvasCtx, results.poseLandmarks, {
      color: "#FF0000",
      lineWidth: 2,
    });
    canvasCtx.restore();

    grid.updateLandmarks(results.poseWorldLandmarks);
  }

  // max related functions

  function posesToMax() {
    window.max.outlet('posesToMax');
    setInterval(setPoses, POSITION_INTERVAL);
  };

  function toObject(arr) {
    var rv = {};
    for (var i = 0; i < arr.length; ++i) rv[i] = arr[i];
    return rv;
  }

  const setPoses = () => {
    window.max.setDict("poses", toObject(poses));
  };
</script>


</html>










